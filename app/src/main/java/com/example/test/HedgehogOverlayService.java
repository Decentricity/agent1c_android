package ai.agent1c.hitomi;

import android.Manifest;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.animation.ValueAnimator;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowInsets;
import android.view.WindowManager;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.speech.RecognitionListener;
import android.speech.RecognizerIntent;
import android.speech.SpeechRecognizer;
import android.os.Bundle;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ScrollView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.core.app.NotificationCompat;
import androidx.core.content.ContextCompat;

import org.json.JSONArray;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class HedgehogOverlayService extends Service {
    public static final String ACTION_START = "ai.agent1c.hitomi.START_OVERLAY";
    public static final String ACTION_STOP = "ai.agent1c.hitomi.STOP_OVERLAY";
    private static final String CHANNEL_ID = "hitomi_overlay_channel";
    private static final int NOTIF_ID = 1017;
    private static final int HEDGEHOG_SIZE_DP = 112;
    private static final int HEDGEHOG_TOUCH_BOX_DP = 124;
    private static final int QUICK_ACTION_X_COMPENSATE_DP = 24;
    private static final int BUBBLE_WIDTH_DP = 260;
    private static final int BUBBLE_X_OFFSET_DP = 74;
    private static final int BUBBLE_GAP_DP = 8;
    private static final int EDGE_TAB_WIDTH_DP = 56;
    private static final int EDGE_TAB_HEIGHT_DP = 112;
    private static final int EDGE_TAB_VISIBLE_SLICE_DP = 10;
    private static final String ANDROID_BROWSER_TOOL_NAME = "android_browser_open";
    private static final String ANDROID_BROWSER_BROWSE_TOOL_NAME = "android_browser_browse";

    private WindowManager windowManager;
    private View hedgehogView;
    private View bubbleView;
    private View browserView;
    private TextView edgeTabView;
    private WindowManager.LayoutParams hedgehogParams;
    private WindowManager.LayoutParams bubbleParams;
    private WindowManager.LayoutParams browserParams;
    private WindowManager.LayoutParams edgeTabParams;
    private boolean bubbleVisible = false;
    private boolean browserVisible = false;
    private final ExecutorService chatExecutor = Executors.newSingleThreadExecutor();
    private final Handler mainHandler = new Handler(Looper.getMainLooper());
    private final JSONArray chatHistory = new JSONArray();
    private HitomiCloudChatClient chatClient;
    private TextView bubbleBodyView;
    private TextView browserUrlView;
    private ScrollView bubbleBodyScrollView;
    private View bubbleTailTopView;
    private View bubbleTailBottomView;
    private EditText bubbleInputView;
    private ImageButton bubbleSendButton;
    private WebView hitomiBrowserWebView;
    private boolean chatInFlight = false;
    private String transcript = "";
    private boolean keyboardLiftActive = false;
    private int keyboardLiftOriginalY = -1;
    private boolean hedgehogDragging = false;
    private ValueAnimator hedgehogHopAnimator;
    private ValueAnimator hedgehogTravelAnimator;
    private boolean bubbleTailOnTop = false;
    private View quickActionsView;
    private ImageButton quickSettingsButton;
    private ImageButton quickMicButton;
    private ImageButton quickCloseButton;
    private ImageButton pinnedMicButton;
    private boolean quickActionsVisible = false;
    private boolean alwaysListeningEnabled = false;
    private SpeechRecognizer speechRecognizer;
    private Intent speechIntent;
    private boolean sttListening = false;
    private boolean sttRestartScheduled = false;
    private boolean sttRecognizerAvailable = false;
    private boolean sttPendingRestartAfterReply = false;
    private boolean sttSuppressUntilNextSession = false;
    private String sttPartialPreview = "";
    private boolean hedgehogHiddenAtEdge = false;
    private boolean hiddenEdgeRight = false;
    private int hiddenRestoreX = -1;
    private int hiddenRestoreY = -1;
    private BrowserReadRequest pendingBrowserReadRequest;
    private final Runnable sttRestartRunnable = new Runnable() {
        @Override public void run() {
            sttRestartScheduled = false;
            if (alwaysListeningEnabled && !chatInFlight) startSpeechListeningSession();
        }
    };
    private static volatile boolean overlayRunning = false;

    public static boolean isOverlayRunning() {
        return overlayRunning;
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        String action = intent != null ? intent.getAction() : ACTION_START;
        if (ACTION_STOP.equals(action)) {
            overlayRunning = false;
            stopSelf();
            return START_NOT_STICKY;
        }
        createNotificationChannel();
        startForeground(NOTIF_ID, buildNotification());
        ensureOverlay();
        overlayRunning = true;
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        overlayRunning = false;
        stopSpeechLoop(true);
        chatExecutor.shutdownNow();
        if (windowManager != null) {
            if (hedgehogView != null) {
                try { windowManager.removeView(hedgehogView); } catch (Exception ignored) {}
            }
            if (bubbleView != null) {
                try { windowManager.removeView(bubbleView); } catch (Exception ignored) {}
            }
            if (browserView != null) {
                try { windowManager.removeView(browserView); } catch (Exception ignored) {}
            }
            if (edgeTabView != null) {
                try { windowManager.removeView(edgeTabView); } catch (Exception ignored) {}
            }
        }
        if (hitomiBrowserWebView != null) {
            try {
                hitomiBrowserWebView.stopLoading();
                hitomiBrowserWebView.destroy();
            } catch (Exception ignored) {}
        }
    }

    private void ensureOverlay() {
        if (windowManager == null) {
            windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
        }
        if (hedgehogView != null) return;

        int overlayType = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
            ? WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
            : WindowManager.LayoutParams.TYPE_PHONE;

        hedgehogView = LayoutInflater.from(this).inflate(R.layout.overlay_hedgehog, null);
        bubbleView = LayoutInflater.from(this).inflate(R.layout.overlay_bubble, null);
        browserView = LayoutInflater.from(this).inflate(R.layout.overlay_browser, null);
        edgeTabView = buildEdgeTabView();

        hedgehogParams = new WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            overlayType,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS,
            PixelFormat.TRANSLUCENT
        );
        hedgehogParams.gravity = Gravity.TOP | Gravity.START;
        hedgehogParams.x = dp(18);
        hedgehogParams.y = dp(220);

        bubbleParams = new WindowManager.LayoutParams(
            dp(BUBBLE_WIDTH_DP),
            WindowManager.LayoutParams.WRAP_CONTENT,
            overlayType,
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS
                | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,
            PixelFormat.TRANSLUCENT
        );
        bubbleParams.gravity = Gravity.TOP | Gravity.START;
        bubbleParams.x = dp(82);
        bubbleParams.y = dp(80);
        browserParams = new WindowManager.LayoutParams(
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            overlayType,
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
            PixelFormat.TRANSLUCENT
        );
        browserParams.gravity = Gravity.TOP | Gravity.START;
        browserParams.x = dp(120);
        browserParams.y = dp(120);
        edgeTabParams = new WindowManager.LayoutParams(
            dp(EDGE_TAB_WIDTH_DP),
            dp(EDGE_TAB_HEIGHT_DP),
            overlayType,
            WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
            PixelFormat.TRANSLUCENT
        );
        edgeTabParams.gravity = Gravity.TOP | Gravity.START;
        edgeTabParams.x = 0;
        edgeTabParams.y = hedgehogParams.y;

        setupBubbleUi();
        setupBrowserUi();
        setupQuickActionsUi();
        setupDragAndTap();

        windowManager.addView(browserView, browserParams);
        windowManager.addView(bubbleView, bubbleParams);
        windowManager.addView(hedgehogView, hedgehogParams);
        windowManager.addView(edgeTabView, edgeTabParams);
        browserView.setVisibility(View.GONE);
        browserVisible = false;
        bubbleView.setVisibility(View.GONE);
        edgeTabView.setVisibility(View.GONE);
        chatClient = new HitomiCloudChatClient(this);
        initSpeechRecognizer();
        SupabaseAuthManager auth = new SupabaseAuthManager(this);
        if (auth.isSignedIn()) {
            String display = String.valueOf(auth.getDisplayName() == null ? "" : auth.getDisplayName()).trim();
            if (display.startsWith("@") && display.length() > 1) {
                transcript = "Hitomi: I'm a hedgey-hog! Hello " + display;
            } else {
                transcript = "Hitomi: Hello, I'm a hedgey-hog!";
            }
        } else {
            transcript = "Hitomi: Hi! I'm Hitomi, your tiny hedgehog friend. Sign in in the app, then we can chat here.";
        }
        renderTranscript(false);
    }

    private void setupBrowserUi() {
        if (browserView == null) return;
        TextView title = browserView.findViewById(R.id.hitomiBrowserTitleText);
        browserUrlView = browserView.findViewById(R.id.hitomiBrowserUrl);
        hitomiBrowserWebView = browserView.findViewById(R.id.hitomiBrowserWebView);
        ImageButton close = browserView.findViewById(R.id.hitomiBrowserClose);
        View dragHandle = browserView.findViewById(R.id.hitomiBrowserTitlePill);
        if (title != null) title.setText("Hitomi Browser");
        if (close != null) close.setOnClickListener(v -> {
            browserVisible = false;
            browserView.setVisibility(View.GONE);
        });
        if (dragHandle != null) setupBrowserDrag(dragHandle);
        if (hitomiBrowserWebView != null) {
            WebSettings ws = hitomiBrowserWebView.getSettings();
            ws.setJavaScriptEnabled(true);
            ws.setDomStorageEnabled(true);
            ws.setLoadsImagesAutomatically(true);
            ws.setBuiltInZoomControls(false);
            hitomiBrowserWebView.setWebViewClient(new WebViewClient() {
                @Override
                public void onPageFinished(WebView view, String url) {
                    super.onPageFinished(view, url);
                    if (browserUrlView != null && url != null) browserUrlView.setText(url);
                    maybeResolvePendingBrowserRead(view, url);
                }
            });
            if (browserUrlView != null) browserUrlView.setText("https://example.com");
            hitomiBrowserWebView.loadUrl("https://example.com");
        }
    }

    private void showHitomiBrowserForUrl(String rawUrl) {
        if (browserView == null || browserParams == null || hitomiBrowserWebView == null) return;
        String url = normalizeBrowserUrl(rawUrl);
        if (url == null || url.isEmpty()) return;
        positionBrowserNearHedgehog();
        browserVisible = true;
        browserView.setVisibility(View.VISIBLE);
        safeUpdate(browserView, browserParams);
        if (browserUrlView != null) browserUrlView.setText(url);
        hitomiBrowserWebView.loadUrl(url);
    }

    private void positionBrowserNearHedgehog() {
        if (hedgehogParams == null || browserParams == null) return;
        int screenW = getScreenWidth();
        int screenH = getScreenHeight();
        int browserW = (browserView != null && browserView.getWidth() > 0) ? browserView.getWidth() : dp(240);
        int browserH = (browserView != null && browserView.getHeight() > 0) ? browserView.getHeight() : dp(190);
        int gap = dp(10);
        int desiredX = hedgehogParams.x + dp(HEDGEHOG_TOUCH_BOX_DP) + gap;
        if (desiredX + browserW > screenW - dp(8)) {
            desiredX = hedgehogParams.x - browserW - gap;
        }
        desiredX = clamp(desiredX, dp(4), Math.max(dp(4), screenW - browserW - dp(4)));
        int desiredY = clamp(hedgehogParams.y - dp(24), 0, Math.max(0, screenH - browserH));
        browserParams.x = desiredX;
        browserParams.y = desiredY;
    }

    private String normalizeBrowserUrl(String rawUrl) {
        if (rawUrl == null) return null;
        String url = rawUrl.trim();
        if (url.isEmpty()) return null;
        if (url.startsWith("http://") || url.startsWith("https://")) return url;
        if (url.matches("^[a-zA-Z][a-zA-Z0-9+.-]*:.*$")) return null;
        return "https://" + url;
    }

    private void requestBrowserSnapshot(String rawUrl, BrowserReadCallback callback) {
        if (callback == null) return;
        String url = normalizeBrowserUrl(rawUrl);
        if (url == null || url.isEmpty() || hitomiBrowserWebView == null) {
            callback.onSnapshot(null);
            return;
        }
        if (pendingBrowserReadRequest != null && pendingBrowserReadRequest.timeoutRunnable != null) {
            mainHandler.removeCallbacks(pendingBrowserReadRequest.timeoutRunnable);
        }
        Runnable timeout = () -> {
            BrowserReadRequest req = pendingBrowserReadRequest;
            if (req == null) return;
            pendingBrowserReadRequest = null;
            req.callback.onSnapshot(null);
        };
        pendingBrowserReadRequest = new BrowserReadRequest(url, callback, timeout);
        showHitomiBrowserForUrl(url);
        mainHandler.postDelayed(timeout, 12000);
    }

    private void maybeResolvePendingBrowserRead(WebView view, String finishedUrl) {
        BrowserReadRequest req = pendingBrowserReadRequest;
        if (req == null || view == null) return;
        // Resolve on first finished page after request; redirects are fine.
        pendingBrowserReadRequest = null;
        if (req.timeoutRunnable != null) mainHandler.removeCallbacks(req.timeoutRunnable);
        String js = "(function(){try{var t=(document.title||'').trim();var u=(location.href||'').trim();"
            + "var b=(document.body&&document.body.innerText?document.body.innerText:'').replace(/\\s+/g,' ').trim();"
            + "if(b.length>4000)b=b.slice(0,4000);"
            + "return JSON.stringify({title:t,url:u,text:b});}catch(e){return JSON.stringify({title:'',url:'',text:''});}})();";
        view.evaluateJavascript(js, value -> {
            BrowserSnapshot snapshot = parseBrowserSnapshotResult(value, finishedUrl);
            req.callback.onSnapshot(snapshot);
        });
    }

    private BrowserSnapshot parseBrowserSnapshotResult(String jsValue, String fallbackUrl) {
        try {
            // evaluateJavascript returns a JSON-encoded Java string
            String decoded = new JSONArray("[" + (jsValue == null ? "\"\"" : jsValue) + "]").getString(0);
            JSONObject obj = new JSONObject(decoded);
            String title = obj.optString("title", "");
            String url = obj.optString("url", "");
            String text = obj.optString("text", "");
            if ((url == null || url.isEmpty()) && fallbackUrl != null) url = fallbackUrl;
            return new BrowserSnapshot(title, url, text);
        } catch (Exception e) {
            return new BrowserSnapshot("", fallbackUrl == null ? "" : fallbackUrl, "");
        }
    }

    private void setupBrowserDrag(View dragHandle) {
        final float[] downRaw = new float[2];
        final int[] downPos = new int[2];
        dragHandle.setOnTouchListener((v, event) -> {
            if (browserParams == null || browserView == null) return false;
            switch (event.getActionMasked()) {
                case MotionEvent.ACTION_DOWN:
                    downRaw[0] = event.getRawX();
                    downRaw[1] = event.getRawY();
                    downPos[0] = browserParams.x;
                    downPos[1] = browserParams.y;
                    return true;
                case MotionEvent.ACTION_MOVE:
                    int dx = (int) (event.getRawX() - downRaw[0]);
                    int dy = (int) (event.getRawY() - downRaw[1]);
                    browserParams.x = clamp(downPos[0] + dx, 0, Math.max(0, getScreenWidth() - dp(240)));
                    browserParams.y = clamp(downPos[1] + dy, 0, Math.max(0, getScreenHeight() - dp(190)));
                    safeUpdate(browserView, browserParams);
                    return true;
                case MotionEvent.ACTION_UP:
                case MotionEvent.ACTION_CANCEL:
                    return true;
                default:
                    return false;
            }
        });
    }

    private TextView buildEdgeTabView() {
        TextView v = new TextView(this);
        v.setText("");
        v.setGravity(Gravity.CENTER);
        GradientDrawable bg = new GradientDrawable();
        bg.setShape(GradientDrawable.OVAL);
        bg.setColor(0xEEF4EFCB);
        bg.setStroke(dp(1), 0x887A775D);
        v.setBackground(bg);
        v.setClickable(true);
        v.setFocusable(false);
        v.setAlpha(0.95f);
        v.setOnClickListener(x -> restoreHedgehogFromEdge());
        return v;
    }

    private void setupBubbleUi() {
        bubbleBodyScrollView = bubbleView.findViewById(R.id.hitomiBubbleBodyScroll);
        bubbleBodyView = bubbleView.findViewById(R.id.hitomiBubbleBody);
        bubbleTailTopView = bubbleView.findViewById(R.id.hitomiBubbleTailTop);
        bubbleTailBottomView = bubbleView.findViewById(R.id.hitomiBubbleTailBottom);
        bubbleInputView = bubbleView.findViewById(R.id.hitomiBubbleInput);
        bubbleSendButton = bubbleView.findViewById(R.id.hitomiBubbleSend);
        ImageButton close = bubbleView.findViewById(R.id.hitomiBubbleClose);
        bubbleSendButton.setOnClickListener(v -> sendChatMessage());
        close.setOnClickListener(v -> toggleBubble(false));
        bubbleView.setOnTouchListener((v, event) -> {
            if (event == null) return false;
            if (event.getActionMasked() == MotionEvent.ACTION_OUTSIDE) {
                toggleBubble(false);
                return false;
            }
            return false;
        });
        bubbleInputView.setOnFocusChangeListener((v, hasFocus) -> {
            if (hasFocus) {
                scheduleKeyboardAvoidanceHop();
            } else {
                restoreFromKeyboardHop(true);
            }
        });
        bubbleInputView.setOnClickListener(v -> scheduleKeyboardAvoidanceHop());
        bubbleView.getViewTreeObserver().addOnGlobalLayoutListener(() -> {
            if (!bubbleVisible || bubbleInputView == null || !bubbleInputView.hasFocus()) return;
            if (hedgehogDragging) {
                scheduleKeyboardAvoidanceHop();
                return;
            }
            int screenH = getScreenHeight();
            int keyboardTop = getKeyboardTop(screenH);
            if (keyboardTop < screenH - dp(40)) {
                ensureKeyboardAvoidanceHop();
            }
        });
    }

    private void setupQuickActionsUi() {
        quickActionsView = hedgehogView.findViewById(R.id.hedgehogQuickActions);
        quickSettingsButton = hedgehogView.findViewById(R.id.hedgehogActionSettings);
        quickMicButton = hedgehogView.findViewById(R.id.hedgehogActionMic);
        quickCloseButton = hedgehogView.findViewById(R.id.hedgehogActionClose);
        pinnedMicButton = hedgehogView.findViewById(R.id.hedgehogPinnedMic);
        if (quickSettingsButton != null) {
            quickSettingsButton.setOnClickListener(v -> {
                showQuickActions(false);
                Intent open = new Intent(this, MainActivity.class);
                open.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivity(open);
            });
        }
        if (quickMicButton != null) {
            quickMicButton.setOnClickListener(v -> {
                toggleAlwaysListeningFromQuickAction();
            });
            updateQuickMicVisual();
        }
        if (pinnedMicButton != null) {
            pinnedMicButton.setOnClickListener(v -> toggleAlwaysListeningFromQuickAction());
        }
        if (quickCloseButton != null) {
            quickCloseButton.setOnClickListener(v -> {
                showQuickActions(false);
                toggleBubble(false);
                hideHedgehogToEdge();
            });
        }
        if (quickActionsView != null) {
            quickActionsView.bringToFront();
        }
        updateQuickMicVisual();
    }

    private void updateQuickMicVisual() {
        if (quickMicButton != null) {
            quickMicButton.setColorFilter(alwaysListeningEnabled ? 0xFF8E44AD : 0xFF333333);
            quickMicButton.setAlpha(alwaysListeningEnabled ? 1f : 0.88f);
        }
        if (pinnedMicButton != null) {
            pinnedMicButton.setColorFilter(alwaysListeningEnabled ? 0xFF8E44AD : 0xFF333333);
            pinnedMicButton.setAlpha(alwaysListeningEnabled ? 1f : 0.92f);
        }
        updatePinnedMicVisibility();
        updateHideActionIcon();
    }

    private void updatePinnedMicVisibility() {
        if (pinnedMicButton == null) return;
        boolean show = alwaysListeningEnabled && !quickActionsVisible && !hedgehogHiddenAtEdge;
        pinnedMicButton.setVisibility(show ? View.VISIBLE : View.GONE);
    }

    private void updateHideActionIcon() {
        if (quickCloseButton == null || hedgehogParams == null) return;
        boolean right = isHedgehogCloserToRightEdge();
        hiddenEdgeRight = right;
        quickCloseButton.setImageResource(right
            ? android.R.drawable.ic_media_ff
            : android.R.drawable.ic_media_rew);
        quickCloseButton.setContentDescription(right ? "Hide to right edge" : "Hide to left edge");
    }

    private boolean isHedgehogCloserToRightEdge() {
        int centerX = hedgehogParams.x + (dp(HEDGEHOG_TOUCH_BOX_DP) / 2);
        return centerX >= (getScreenWidth() / 2);
    }

    private void toggleAlwaysListeningFromQuickAction() {
        showQuickActions(false);
        if (!alwaysListeningEnabled) {
            if (!ensureMicPermission()) {
                Toast.makeText(this, "Allow microphone permission in Hitomi app first.", Toast.LENGTH_SHORT).show();
                return;
            }
            if (!sttRecognizerAvailable) {
                Toast.makeText(this, "Speech recognition is unavailable on this device.", Toast.LENGTH_SHORT).show();
                return;
            }
        }
        alwaysListeningEnabled = !alwaysListeningEnabled;
        updateQuickMicVisual();
        if (alwaysListeningEnabled) {
            sttSuppressUntilNextSession = false;
            scheduleSpeechRestart(40);
            Toast.makeText(this, "Always listening enabled", Toast.LENGTH_SHORT).show();
        } else {
            stopSpeechLoop(false);
            Toast.makeText(this, "Always listening disabled", Toast.LENGTH_SHORT).show();
        }
    }

    private boolean ensureMicPermission() {
        boolean granted = ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO)
            == PackageManager.PERMISSION_GRANTED;
        if (granted) return true;
        Intent open = new Intent(this, MainActivity.class);
        open.putExtra(MainActivity.EXTRA_REQUEST_MIC_PERMISSION, true);
        open.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        startActivity(open);
        return false;
    }

    private void initSpeechRecognizer() {
        if (speechRecognizer != null) return;
        try {
            sttRecognizerAvailable = SpeechRecognizer.isRecognitionAvailable(this);
            if (!sttRecognizerAvailable) return;
            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(this);
            speechIntent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
            speechIntent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
            speechIntent.putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true);
            speechIntent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1);
            speechIntent.putExtra(RecognizerIntent.EXTRA_PREFER_OFFLINE, false);
            speechRecognizer.setRecognitionListener(new RecognitionListener() {
                @Override public void onReadyForSpeech(Bundle params) {
                    sttListening = true;
                    sttPartialPreview = "";
                    renderTranscript(chatInFlight);
                }
                @Override public void onBeginningOfSpeech() {}
                @Override public void onRmsChanged(float rmsdB) {}
                @Override public void onBufferReceived(byte[] buffer) {}
                @Override public void onEndOfSpeech() {
                    sttListening = false;
                }
                @Override public void onError(int error) {
                    sttListening = false;
                    sttPartialPreview = "";
                    renderTranscript(chatInFlight);
                    if (!alwaysListeningEnabled) return;
                    if (error == SpeechRecognizer.ERROR_RECOGNIZER_BUSY) {
                        scheduleSpeechRestart(420);
                        return;
                    }
                    if (error == SpeechRecognizer.ERROR_NO_MATCH || error == SpeechRecognizer.ERROR_SPEECH_TIMEOUT) {
                        scheduleSpeechRestart(180);
                        return;
                    }
                    scheduleSpeechRestart(500);
                }
                @Override public void onResults(Bundle results) {
                    sttListening = false;
                    sttPartialPreview = "";
                    handleSpeechResults(results, true);
                }
                @Override public void onPartialResults(Bundle partialResults) {
                    if (partialResults == null) return;
                    java.util.ArrayList<String> matches = partialResults.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
                    if (matches == null || matches.isEmpty()) return;
                    String partial = String.valueOf(matches.get(0)).trim();
                    if (partial.isEmpty()) return;
                    sttPartialPreview = "Listening: " + partial;
                    renderTranscript(chatInFlight);
                }
                @Override public void onEvent(int eventType, Bundle params) {}
            });
        } catch (Exception ignored) {
            sttRecognizerAvailable = false;
            speechRecognizer = null;
        }
    }

    private void handleSpeechResults(Bundle results, boolean autoSend) {
        if (results == null) {
            if (alwaysListeningEnabled && !chatInFlight) scheduleSpeechRestart(180);
            return;
        }
        java.util.ArrayList<String> matches = results.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION);
        if (matches == null || matches.isEmpty()) {
            if (alwaysListeningEnabled && !chatInFlight) scheduleSpeechRestart(180);
            return;
        }
        String spoken = String.valueOf(matches.get(0)).trim();
        if (spoken.isEmpty()) {
            if (alwaysListeningEnabled && !chatInFlight) scheduleSpeechRestart(180);
            return;
        }
        if (chatInFlight) {
            sttPendingRestartAfterReply = true;
            scheduleSpeechRestart(420);
            return;
        }
        if (!bubbleVisible) toggleBubble(true);
        if (bubbleInputView != null) bubbleInputView.setText(spoken);
        if (autoSend) {
            sttPendingRestartAfterReply = alwaysListeningEnabled;
            sendChatMessage();
        } else if (alwaysListeningEnabled) {
            scheduleSpeechRestart(220);
        }
    }

    private void startSpeechListeningSession() {
        if (!alwaysListeningEnabled) return;
        if (chatInFlight) return;
        if (!ensureMicPermission()) return;
        if (!sttRecognizerAvailable || speechRecognizer == null || speechIntent == null) {
            if (speechRecognizer == null) initSpeechRecognizer();
            if (!sttRecognizerAvailable || speechRecognizer == null || speechIntent == null) return;
        }
        if (sttListening) return;
        if (sttSuppressUntilNextSession) {
            sttSuppressUntilNextSession = false;
        }
        try {
            speechRecognizer.cancel();
        } catch (Exception ignored) {}
        try {
            speechRecognizer.startListening(speechIntent);
        } catch (Exception ignored) {
            scheduleSpeechRestart(500);
        }
    }

    private void scheduleSpeechRestart(long delayMs) {
        if (!alwaysListeningEnabled) return;
        mainHandler.removeCallbacks(sttRestartRunnable);
        sttRestartScheduled = true;
        mainHandler.postDelayed(sttRestartRunnable, Math.max(40L, delayMs));
    }

    private void stopSpeechLoop(boolean destroyRecognizer) {
        mainHandler.removeCallbacks(sttRestartRunnable);
        sttRestartScheduled = false;
        sttListening = false;
        sttPartialPreview = "";
        try {
            if (speechRecognizer != null) speechRecognizer.cancel();
        } catch (Exception ignored) {}
        if (destroyRecognizer) {
            try {
                if (speechRecognizer != null) speechRecognizer.destroy();
            } catch (Exception ignored) {}
            speechRecognizer = null;
        }
        renderTranscript(chatInFlight);
    }

    private void showQuickActions(boolean show) {
        if (quickActionsVisible == show) return;
        if (quickActionsView == null) return;
        quickActionsVisible = show;
        int compensate = dp(QUICK_ACTION_X_COMPENSATE_DP);
        if (show) {
            hedgehogParams.x = clamp(
                hedgehogParams.x - compensate,
                0,
                Math.max(0, getScreenWidth() - dp(HEDGEHOG_TOUCH_BOX_DP))
            );
        } else {
            hedgehogParams.x = clamp(
                hedgehogParams.x + compensate,
                0,
                Math.max(0, getScreenWidth() - dp(HEDGEHOG_TOUCH_BOX_DP))
            );
        }
        positionBubbleNearHedgehog();
        safeUpdate(hedgehogView, hedgehogParams);
        if (bubbleVisible) safeUpdate(bubbleView, bubbleParams);
        if (show) {
            updateHideActionIcon();
            quickActionsView.bringToFront();
            quickActionsView.setVisibility(View.VISIBLE);
            View[] buttons = new View[]{ quickSettingsButton, quickMicButton, quickCloseButton };
            for (int i = 0; i < buttons.length; i++) {
                View btn = buttons[i];
                if (btn == null) continue;
                btn.animate().cancel();
                btn.setAlpha(0f);
                btn.setScaleX(0.7f);
                btn.setScaleY(0.7f);
                btn.setTranslationX(dp(8));
                btn.animate()
                    .alpha(1f)
                    .scaleX(1f)
                    .scaleY(1f)
                    .translationX(0f)
                    .setStartDelay(i * 22L)
                    .setDuration(130)
                    .start();
            }
            return;
        }
        View[] buttons = new View[]{ quickSettingsButton, quickMicButton, quickCloseButton };
        for (View btn : buttons) {
            if (btn == null) continue;
            btn.animate().cancel();
            btn.animate()
                .alpha(0f)
                .scaleX(0.75f)
                .scaleY(0.75f)
                .translationX(dp(6))
                .setDuration(90)
                .start();
        }
        quickActionsView.postDelayed(() -> {
            if (!quickActionsVisible && quickActionsView != null) {
                quickActionsView.setVisibility(View.GONE);
                for (View btn : buttons) {
                    if (btn == null) continue;
                    btn.setAlpha(1f);
                    btn.setScaleX(1f);
                    btn.setScaleY(1f);
                    btn.setTranslationX(0f);
                }
            }
        }, 100);
    }

    private void setupDragAndTap() {
        final float[] downRaw = new float[2];
        final int[] downPos = new int[2];
        final boolean[] dragging = new boolean[1];
        final boolean[] longPressed = new boolean[1];
        final Runnable[] longPressTrigger = new Runnable[1];
        View touchTarget = hedgehogView.findViewById(R.id.hedgehogImage);
        if (touchTarget == null) touchTarget = hedgehogView;
        final View finalTouchTarget = touchTarget;

        finalTouchTarget.setOnTouchListener((v, event) -> {
            switch (event.getActionMasked()) {
                case MotionEvent.ACTION_DOWN:
                    if (!isOpaqueTouchOnHedgehog(v, event)) {
                        return false;
                    }
                    dragging[0] = false;
                    hedgehogDragging = false;
                    longPressed[0] = false;
                    downRaw[0] = event.getRawX();
                    downRaw[1] = event.getRawY();
                    downPos[0] = hedgehogParams.x;
                    downPos[1] = hedgehogParams.y;
                    if (hedgehogHiddenAtEdge) return false;
                    if (longPressTrigger[0] != null) mainHandler.removeCallbacks(longPressTrigger[0]);
                    longPressTrigger[0] = () -> {
                        if (!dragging[0]) {
                            longPressed[0] = true;
                            showQuickActions(!quickActionsVisible);
                        }
                    };
                    mainHandler.postDelayed(longPressTrigger[0], 420);
                    return true;
                case MotionEvent.ACTION_MOVE:
                    int dx = (int) (event.getRawX() - downRaw[0]);
                    int dy = (int) (event.getRawY() - downRaw[1]);
                    if (Math.abs(dx) > 8 || Math.abs(dy) > 8) {
                        dragging[0] = true;
                        hedgehogDragging = true;
                        if (longPressTrigger[0] != null) mainHandler.removeCallbacks(longPressTrigger[0]);
                        if (quickActionsVisible) showQuickActions(false);
                    }
                    hedgehogParams.x = clamp(downPos[0] + dx, 0, Math.max(0, getScreenWidth() - dp(HEDGEHOG_TOUCH_BOX_DP)));
                    hedgehogParams.y = clamp(downPos[1] + dy, 0, Math.max(0, getScreenHeight() - dp(HEDGEHOG_TOUCH_BOX_DP)));
                    positionBubbleNearHedgehog();
                    safeUpdate(hedgehogView, hedgehogParams);
                    positionEdgeTabForHiddenState();
                    if (bubbleVisible) safeUpdate(bubbleView, bubbleParams);
                    return true;
                case MotionEvent.ACTION_UP:
                    if (longPressTrigger[0] != null) mainHandler.removeCallbacks(longPressTrigger[0]);
                    hedgehogDragging = false;
                    if (longPressed[0]) return true;
                    if (!dragging[0]) {
                        if (quickActionsVisible) showQuickActions(false);
                        else toggleBubble(!bubbleVisible);
                    } else if (bubbleVisible && bubbleInputView != null && bubbleInputView.hasFocus()) {
                        scheduleKeyboardAvoidanceHop();
                    }
                    return true;
                case MotionEvent.ACTION_CANCEL:
                    if (longPressTrigger[0] != null) mainHandler.removeCallbacks(longPressTrigger[0]);
                    hedgehogDragging = false;
                    return true;
                default:
                    return false;
            }
        });
    }

    private boolean isOpaqueTouchOnHedgehog(View v, MotionEvent event) {
        if (!(v instanceof ImageView)) return true;
        ImageView image = (ImageView) v;
        Drawable drawable = image.getDrawable();
        if (!(drawable instanceof BitmapDrawable)) return true;
        BitmapDrawable bd = (BitmapDrawable) drawable;
        if (bd.getBitmap() == null) return true;
        android.graphics.Bitmap bmp = bd.getBitmap();
        if (bmp.getWidth() <= 0 || bmp.getHeight() <= 0) return true;

        float touchX = event.getX();
        float touchY = event.getY();
        int vw = image.getWidth();
        int vh = image.getHeight();
        int dw = drawable.getIntrinsicWidth();
        int dh = drawable.getIntrinsicHeight();
        if (vw <= 0 || vh <= 0 || dw <= 0 || dh <= 0) return true;

        float scale = Math.min((float) vw / (float) dw, (float) vh / (float) dh);
        float renderedW = dw * scale;
        float renderedH = dh * scale;
        float left = (vw - renderedW) / 2f;
        float top = (vh - renderedH) / 2f;
        if (touchX < left || touchY < top || touchX > left + renderedW || touchY > top + renderedH) {
            return false;
        }
        float normX = (touchX - left) / renderedW;
        float normY = (touchY - top) / renderedH;
        int px = Math.max(0, Math.min(bmp.getWidth() - 1, (int) (normX * bmp.getWidth())));
        int py = Math.max(0, Math.min(bmp.getHeight() - 1, (int) (normY * bmp.getHeight())));
        int alpha = (bmp.getPixel(px, py) >>> 24) & 0xFF;
        return alpha >= 24;
    }

    private void toggleBubble(boolean show) {
        if (hedgehogHiddenAtEdge && show) {
            restoreHedgehogFromEdge();
            return;
        }
        bubbleVisible = show;
        if (bubbleView == null) return;
        if (show) {
            showQuickActions(false);
            positionBubbleNearHedgehog();
            safeUpdate(bubbleView, bubbleParams);
            bubbleView.setVisibility(View.VISIBLE);
            if (bubbleInputView != null) {
                bubbleInputView.requestFocus();
                scheduleKeyboardAvoidanceHop();
            }
            bubbleView.post(this::ensureKeyboardAvoidanceHop);
            bubbleView.postDelayed(this::ensureKeyboardAvoidanceHop, 120);
        } else {
            if (bubbleInputView != null) bubbleInputView.clearFocus();
            bubbleView.setVisibility(View.GONE);
            restoreFromKeyboardHop(true);
        }
        updatePinnedMicVisibility();
    }

    private void positionBubbleNearHedgehog() {
        if (hedgehogHiddenAtEdge) return;
        int bubbleWidth = dp(BUBBLE_WIDTH_DP);
        int bubbleX = hedgehogParams.x - dp(BUBBLE_X_OFFSET_DP);
        int bubbleHeight = getBubbleMeasuredHeight();
        int screenH = getScreenHeight();
        int keyboardTop = getKeyboardTop(screenH);
        int imeBottom = getImeBottomInset();
        int hedgehogCenterY = hedgehogParams.y + (dp(HEDGEHOG_TOUCH_BOX_DP) / 2);
        boolean placeBelow = hedgehogCenterY < Math.round(screenH * 0.4f);
        if (imeBottom > 0 && placeBelow) {
            int belowBottom = hedgehogParams.y + dp(HEDGEHOG_TOUCH_BOX_DP) + dp(BUBBLE_GAP_DP) + bubbleHeight;
            if (belowBottom > keyboardTop - dp(6)) {
                placeBelow = false;
            }
        }
        int bubbleY = placeBelow
            ? hedgehogParams.y + dp(HEDGEHOG_TOUCH_BOX_DP) + dp(BUBBLE_GAP_DP)
            : hedgehogParams.y - bubbleHeight - dp(BUBBLE_GAP_DP);
        bubbleTailOnTop = placeBelow;
        updateBubbleTailPlacement();
        bubbleParams.x = clamp(bubbleX, 0, Math.max(0, getScreenWidth() - bubbleWidth));
        int bottomMax = Math.max(0, screenH - bubbleHeight);
        if (imeBottom > 0 && keyboardTop < screenH - dp(40)) {
            bottomMax = Math.max(0, Math.min(bottomMax, keyboardTop - bubbleHeight - dp(6)));
        }
        bubbleParams.y = clamp(bubbleY, 0, bottomMax);
        positionBubbleTailTowardHedgehog();
    }

    private void positionEdgeTabForHiddenState() {
        if (edgeTabView == null || edgeTabParams == null || hedgehogParams == null) return;
        int tabW = dp(EDGE_TAB_WIDTH_DP);
        int tabH = dp(EDGE_TAB_HEIGHT_DP);
        int visibleSlice = dp(EDGE_TAB_VISIBLE_SLICE_DP);
        edgeTabParams.y = clamp(
            hedgehogParams.y + (dp(HEDGEHOG_TOUCH_BOX_DP) - tabH) / 2,
            0,
            Math.max(0, getScreenHeight() - tabH)
        );
        edgeTabParams.x = hiddenEdgeRight
            ? (getScreenWidth() - visibleSlice)
            : -(tabW - visibleSlice);
    }

    private void updateBubbleTailPlacement() {
        if (bubbleTailTopView == null || bubbleTailBottomView == null) return;
        bubbleTailTopView.setVisibility(bubbleTailOnTop ? View.VISIBLE : View.GONE);
        bubbleTailBottomView.setVisibility(bubbleTailOnTop ? View.GONE : View.VISIBLE);
    }

    private void positionBubbleTailTowardHedgehog() {
        View tail = bubbleTailOnTop ? bubbleTailTopView : bubbleTailBottomView;
        if (tail == null) return;
        int bubbleWidth = dp(BUBBLE_WIDTH_DP);
        int tailWidth = tail.getWidth() > 0 ? tail.getWidth() : dp(18);
        int hedgehogHeadCenterX = hedgehogParams.x + (dp(HEDGEHOG_TOUCH_BOX_DP) / 2);
        int targetCenterWithinBubble = hedgehogHeadCenterX - bubbleParams.x;
        int defaultCenter = bubbleWidth / 2;
        int minCenter = dp(16) + (tailWidth / 2);
        int maxCenter = bubbleWidth - dp(16) - (tailWidth / 2);
        int clampedCenter = clamp(targetCenterWithinBubble, minCenter, maxCenter);
        float dx = clampedCenter - defaultCenter;
        tail.setTranslationX(dx);
    }

    private int getBubbleMeasuredHeight() {
        if (bubbleView == null) return dp(220);
        int widthSpec = View.MeasureSpec.makeMeasureSpec(dp(BUBBLE_WIDTH_DP), View.MeasureSpec.EXACTLY);
        int heightSpec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
        try {
            bubbleView.measure(widthSpec, heightSpec);
            int h = bubbleView.getMeasuredHeight();
            if (h > 0) return h;
        } catch (Exception ignored) {
        }
        return dp(220);
    }

    private void safeUpdate(View view, WindowManager.LayoutParams lp) {
        if (windowManager == null || view == null) return;
        try {
            if (view.getWindowToken() != null) windowManager.updateViewLayout(view, lp);
        } catch (Exception ignored) {
        }
    }

    private Notification buildNotification() {
        Intent openIntent = new Intent(this, MainActivity.class);
        int flags = PendingIntent.FLAG_UPDATE_CURRENT;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) flags |= PendingIntent.FLAG_IMMUTABLE;
        PendingIntent pending = PendingIntent.getActivity(this, 0, openIntent, flags);
        return new NotificationCompat.Builder(this, CHANNEL_ID)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setContentTitle("Hitomi overlay running")
            .setContentText("Tap to manage the floating hedgehog.")
            .setContentIntent(pending)
            .setOngoing(true)
            .build();
    }

    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return;
        NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        if (nm == null) return;
        NotificationChannel channel = new NotificationChannel(
            CHANNEL_ID,
            "Hitomi Overlay",
            NotificationManager.IMPORTANCE_LOW
        );
        nm.createNotificationChannel(channel);
    }

    private int dp(int value) {
        return Math.round(value * getResources().getDisplayMetrics().density);
    }

    private int getScreenWidth() {
        return getResources().getDisplayMetrics().widthPixels;
    }

    private int getScreenHeight() {
        return getResources().getDisplayMetrics().heightPixels;
    }

    private static int clamp(int v, int min, int max) {
        return Math.max(min, Math.min(max, v));
    }

    private void sendChatMessage() {
        if (chatInFlight || bubbleInputView == null) return;
        String msg = bubbleInputView.getText().toString().trim();
        if (msg.isEmpty()) return;
        bubbleInputView.setText("");
        scheduleKeyboardAvoidanceHop();
        appendTranscriptLine("You: " + msg);
        chatInFlight = true;
        renderTranscript(true);
        if (bubbleSendButton != null) bubbleSendButton.setEnabled(false);

        chatExecutor.execute(() -> {
            String reply;
            String userName = "friend";
            try {
                SupabaseAuthManager auth = new SupabaseAuthManager(this);
                String resolved = auth.getDisplayName();
                if (resolved != null && !resolved.trim().isEmpty()) userName = resolved.trim();
                chatHistory.put(new JSONObject().put("role", "user").put("content", msg));
                reply = chatClient.send(chatHistory, userName);
            } catch (Exception e) {
                reply = "I hit a snag: " + safeMessage(e);
            }
            final ParsedAssistantReply parsedReply = parseAssistantReply(reply);
            try {
                chatHistory.put(new JSONObject().put("role", "assistant").put("content", parsedReply.visibleText));
            } catch (Exception ignored) {
            }
            final String finalUserName = userName;
            mainHandler.post(() -> {
                if (parsedReply.browserUrl != null && !parsedReply.browserUrl.isEmpty()) {
                    showHitomiBrowserForUrl(parsedReply.browserUrl);
                }
                appendTranscriptLine("Hitomi: " + parsedReply.visibleText);
                renderTranscript(true);
            });
            if (parsedReply.browserReadUrl != null && !parsedReply.browserReadUrl.isEmpty()) {
                String followup = runBrowserReadFollowup(finalUserName, parsedReply.browserReadUrl);
                if (followup != null && !followup.trim().isEmpty()) {
                    try {
                        chatHistory.put(new JSONObject().put("role", "assistant").put("content", followup));
                    } catch (Exception ignored) {
                    }
                    final String visibleFollowup = followup.trim();
                    mainHandler.post(() -> appendTranscriptLine("Hitomi: " + visibleFollowup));
                }
            }
            mainHandler.post(() -> {
                chatInFlight = false;
                renderTranscript(false);
                if (bubbleSendButton != null) bubbleSendButton.setEnabled(true);
                if (alwaysListeningEnabled && sttPendingRestartAfterReply) {
                    sttPendingRestartAfterReply = false;
                    scheduleSpeechRestart(200);
                }
            });
        });
    }

    private void appendTranscriptLine(String line) {
        if (transcript == null || transcript.isEmpty()) transcript = line;
        else transcript = transcript + "\n\n" + line;
    }

    private ParsedAssistantReply parseAssistantReply(String raw) {
        String source = raw == null ? "" : raw.trim();
        if (source.isEmpty()) return new ParsedAssistantReply("", null, null);
        StringBuilder visible = new StringBuilder();
        List<String> browserUrls = new ArrayList<>();
        List<String> browserReadUrls = new ArrayList<>();
        int idx = 0;
        while (idx < source.length()) {
            int start = source.indexOf("{{tool:", idx);
            if (start < 0) {
                visible.append(source.substring(idx));
                break;
            }
            visible.append(source, idx, start);
            int end = source.indexOf("}}", start);
            if (end < 0) {
                visible.append(source.substring(start));
                break;
            }
            String tokenBody = source.substring(start + 2, end).trim();
            maybeExtractAndroidBrowserTool(tokenBody, browserUrls, browserReadUrls);
            idx = end + 2;
        }
        String cleaned = visible.toString()
            .replaceAll("[ \\t]+\\n", "\n")
            .replaceAll("\\n{3,}", "\n\n")
            .trim();
        if (cleaned.isEmpty() && !browserUrls.isEmpty()) {
            cleaned = "Opening the Hitomi Browser so you can watch me browse.";
        }
        if (cleaned.isEmpty() && !browserReadUrls.isEmpty()) {
            cleaned = "Opening the Hitomi Browser and reading the page for you.";
        }
        return new ParsedAssistantReply(
            cleaned,
            browserUrls.isEmpty() ? null : browserUrls.get(0),
            browserReadUrls.isEmpty() ? null : browserReadUrls.get(0)
        );
    }

    private void maybeExtractAndroidBrowserTool(String tokenBody, List<String> browserUrls, List<String> browserReadUrls) {
        if (tokenBody == null || !tokenBody.startsWith("tool:")) return;
        String payload = tokenBody.substring("tool:".length());
        String[] parts = payload.split("\\|");
        if (parts.length == 0) return;
        String toolName = parts[0].trim();
        boolean openOnly = ANDROID_BROWSER_TOOL_NAME.equals(toolName);
        boolean browseRead = ANDROID_BROWSER_BROWSE_TOOL_NAME.equals(toolName);
        if (!openOnly && !browseRead) return;
        for (int i = 1; i < parts.length; i++) {
            String part = parts[i];
            int eq = part.indexOf('=');
            if (eq <= 0) continue;
            String key = part.substring(0, eq).trim();
            String val = part.substring(eq + 1).trim();
            if (!"url".equalsIgnoreCase(key)) continue;
            String normalized = normalizeBrowserUrl(val);
            if (normalized != null && !normalized.isEmpty()) {
                if (browseRead) browserReadUrls.add(normalized);
                else browserUrls.add(normalized);
            }
            return;
        }
    }

    private String runBrowserReadFollowup(String userName, String browserReadUrl) {
        try {
            CountDownLatch latch = new CountDownLatch(1);
            final BrowserSnapshot[] holder = new BrowserSnapshot[1];
            mainHandler.post(() -> requestBrowserSnapshot(browserReadUrl, snapshot -> {
                holder[0] = snapshot;
                latch.countDown();
            }));
            latch.await(15, TimeUnit.SECONDS);
            BrowserSnapshot snapshot = holder[0];
            if (snapshot == null) {
                return "I opened the Hitomi Browser, but I couldn't read the page yet. Please try again.";
            }
            String toolResult = buildBrowserSnapshotToolResult(snapshot);
            try {
                chatHistory.put(new JSONObject().put("role", "user").put("content", toolResult));
            } catch (Exception ignored) {
            }
            return chatClient.send(chatHistory, userName);
        } catch (Exception e) {
            return "I opened the Hitomi Browser, but I hit a snag reading the page: " + safeMessage(e);
        }
    }

    private String buildBrowserSnapshotToolResult(BrowserSnapshot snapshot) {
        String title = snapshot.title == null ? "" : snapshot.title.trim();
        String url = snapshot.url == null ? "" : snapshot.url.trim();
        String text = snapshot.text == null ? "" : snapshot.text.trim();
        if (text.length() > 3500) text = text.substring(0, 3500);
        return "[ANDROID_BROWSER_PAGE]\n"
            + "Hitomi Browser is visible and loaded.\n"
            + "URL: " + url + "\n"
            + "Title: " + title + "\n"
            + "Visible text excerpt:\n" + text + "\n"
            + "[/ANDROID_BROWSER_PAGE]\n"
            + "Use this page excerpt to answer the user. If the excerpt is insufficient, say so briefly.";
    }

    private static final class ParsedAssistantReply {
        final String visibleText;
        final String browserUrl;
        final String browserReadUrl;
        ParsedAssistantReply(String visibleText, String browserUrl, String browserReadUrl) {
            this.visibleText = (visibleText == null || visibleText.trim().isEmpty())
                ? "Okay."
                : visibleText.trim();
            this.browserUrl = browserUrl;
            this.browserReadUrl = browserReadUrl;
        }
    }

    private interface BrowserReadCallback {
        void onSnapshot(BrowserSnapshot snapshot);
    }

    private static final class BrowserReadRequest {
        final String requestedUrl;
        final BrowserReadCallback callback;
        final Runnable timeoutRunnable;
        BrowserReadRequest(String requestedUrl, BrowserReadCallback callback, Runnable timeoutRunnable) {
            this.requestedUrl = requestedUrl;
            this.callback = callback;
            this.timeoutRunnable = timeoutRunnable;
        }
    }

    private static final class BrowserSnapshot {
        final String title;
        final String url;
        final String text;
        BrowserSnapshot(String title, String url, String text) {
            this.title = title == null ? "" : title;
            this.url = url == null ? "" : url;
            this.text = text == null ? "" : text;
        }
    }

    private void renderTranscript(boolean thinking) {
        if (bubbleBodyView == null) return;
        String text = transcript == null ? "" : transcript;
        if (alwaysListeningEnabled) {
            text = text + (text.isEmpty() ? "" : "\n\n") + "Listening...";
            if (sttPartialPreview != null && !sttPartialPreview.isEmpty()) {
                text = text + "\n" + sttPartialPreview;
            }
        } else if (sttPartialPreview != null && !sttPartialPreview.isEmpty()) {
            text = text + (text.isEmpty() ? "" : "\n\n") + sttPartialPreview;
        }
        if (thinking) text = text + "\n\nThinking...";
        bubbleBodyView.setText(text);
        if (bubbleBodyScrollView != null) {
            bubbleBodyScrollView.post(() -> bubbleBodyScrollView.fullScroll(View.FOCUS_DOWN));
        }
    }

    private void scheduleKeyboardAvoidanceHop() {
        mainHandler.postDelayed(this::ensureKeyboardAvoidanceHop, 80);
        mainHandler.postDelayed(this::ensureKeyboardAvoidanceHop, 220);
    }

    private void ensureKeyboardAvoidanceHop() {
        if (hedgehogView == null || hedgehogParams == null) return;
        if (hedgehogDragging) {
            mainHandler.postDelayed(this::ensureKeyboardAvoidanceHop, 120);
            return;
        }
        int screenH = getScreenHeight();
        int keyboardTopEstimate = getKeyboardTop(screenH);
        if (keyboardTopEstimate >= screenH - dp(40)) return;
        if (bubbleVisible) {
            // Re-evaluate placement first (can flip below->above when keyboard is open).
            positionBubbleNearHedgehog();
            safeUpdate(bubbleView, bubbleParams);
        }
        int hedgehogBottom = hedgehogParams.y + dp(HEDGEHOG_TOUCH_BOX_DP);
        int overlayBottom = hedgehogBottom;
        if (bubbleVisible && bubbleView != null) {
            int bubbleHeight = getBubbleMeasuredHeight();
            int bubbleBottom = bubbleParams.y + bubbleHeight;
            overlayBottom = Math.max(overlayBottom, bubbleBottom);
        }
        if (overlayBottom <= keyboardTopEstimate) return;
        int liftPx = overlayBottom - keyboardTopEstimate + dp(14);
        if (bubbleVisible && bubbleTailOnTop) {
            liftPx += Math.round(screenH * 0.06f);
        }
        int targetY = clamp(hedgehogParams.y - liftPx, 0, Math.max(0, screenH - dp(HEDGEHOG_TOUCH_BOX_DP)));
        if (!keyboardLiftActive) {
            keyboardLiftOriginalY = hedgehogParams.y;
            keyboardLiftActive = true;
        }
        animateHedgehogHopTo(targetY);
    }

    private int getKeyboardTop(int screenH) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            try {
                int imeBottom = getImeBottomInset();
                if (imeBottom > 0) return screenH - imeBottom;
            } catch (Exception ignored) {
            }
        }
        try {
            View frameSource = bubbleView != null ? bubbleView : hedgehogView;
            if (frameSource != null) {
                Rect r = new Rect();
                frameSource.getWindowVisibleDisplayFrame(r);
                if (r.bottom > 0 && r.bottom < screenH) {
                    return r.bottom;
                }
            }
        } catch (Exception ignored) {
        }
        return screenH - dp(270);
    }

    private int getImeBottomInset() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) return 0;
        try {
            View insetSource = bubbleView != null ? bubbleView : hedgehogView;
            if (insetSource == null) return 0;
            WindowInsets insets = insetSource.getRootWindowInsets();
            if (insets == null) return 0;
            return insets.getInsets(WindowInsets.Type.ime()).bottom;
        } catch (Exception ignored) {
            return 0;
        }
    }

    private void restoreFromKeyboardHop(boolean animated) {
        if (!keyboardLiftActive) return;
        int targetY = keyboardLiftOriginalY >= 0 ? keyboardLiftOriginalY : hedgehogParams.y;
        keyboardLiftActive = false;
        keyboardLiftOriginalY = -1;
        if (animated) animateHedgehogHopTo(targetY);
        else {
            hedgehogParams.y = targetY;
            positionBubbleNearHedgehog();
            safeUpdate(hedgehogView, hedgehogParams);
            if (bubbleVisible) safeUpdate(bubbleView, bubbleParams);
        }
    }

    private void animateHedgehogHopTo(int targetY) {
        if (hedgehogView == null || hedgehogParams == null) return;
        int startY = hedgehogParams.y;
        if (startY == targetY) return;
        if (hedgehogHopAnimator != null) hedgehogHopAnimator.cancel();
        final int delta = targetY - startY;
        hedgehogHopAnimator = ValueAnimator.ofFloat(0f, 1f);
        hedgehogHopAnimator.setDuration(260L);
        hedgehogHopAnimator.addUpdateListener(anim -> {
            float t = (float) anim.getAnimatedValue();
            float arc = (float) Math.sin(Math.PI * t) * dp(22);
            int y = Math.round(startY + (delta * t) - arc);
            hedgehogParams.y = clamp(y, 0, Math.max(0, getScreenHeight() - dp(HEDGEHOG_TOUCH_BOX_DP)));
            positionBubbleNearHedgehog();
            safeUpdate(hedgehogView, hedgehogParams);
            if (bubbleVisible) safeUpdate(bubbleView, bubbleParams);
        });
        hedgehogHopAnimator.start();
    }

    private void animateHedgehogTravelTo(int targetX, int targetY, @Nullable Runnable onEnd) {
        animateHedgehogTravelTo(targetX, targetY, false, onEnd);
    }

    private void animateHedgehogTravelTo(int targetX, int targetY, boolean allowOffscreenX, @Nullable Runnable onEnd) {
        if (hedgehogView == null || hedgehogParams == null) {
            if (onEnd != null) onEnd.run();
            return;
        }
        if (hedgehogTravelAnimator != null) hedgehogTravelAnimator.cancel();
        int startX = hedgehogParams.x;
        int startY = hedgehogParams.y;
        if (startX == targetX && startY == targetY) {
            if (onEnd != null) onEnd.run();
            return;
        }
        final int dx = targetX - startX;
        final int dy = targetY - startY;
        final float distance = (float) Math.hypot(dx, dy);
        final float arcAmp = dp(Math.max(18, Math.min(42, Math.round(distance / 10f))));
        hedgehogTravelAnimator = ValueAnimator.ofFloat(0f, 1f);
        hedgehogTravelAnimator.setDuration(Math.max(180L, Math.min(420L, 170L + (long) (distance * 0.7f))));
        hedgehogTravelAnimator.addUpdateListener(anim -> {
            float t = (float) anim.getAnimatedValue();
            float arc = (float) Math.sin(Math.PI * t) * arcAmp;
            int nextX = Math.round(startX + (dx * t));
            hedgehogParams.x = allowOffscreenX
                ? nextX
                : clamp(nextX, 0, Math.max(0, getScreenWidth() - dp(HEDGEHOG_TOUCH_BOX_DP)));
            hedgehogParams.y = clamp(Math.round(startY + (dy * t) - arc), 0, Math.max(0, getScreenHeight() - dp(HEDGEHOG_TOUCH_BOX_DP)));
            positionBubbleNearHedgehog();
            safeUpdate(hedgehogView, hedgehogParams);
            if (bubbleVisible) safeUpdate(bubbleView, bubbleParams);
        });
        hedgehogTravelAnimator.addListener(new android.animation.AnimatorListenerAdapter() {
            private boolean cancelled = false;
            @Override public void onAnimationCancel(android.animation.Animator animation) { cancelled = true; }
            @Override public void onAnimationEnd(android.animation.Animator animation) {
                if (!cancelled && onEnd != null) onEnd.run();
            }
        });
        hedgehogTravelAnimator.start();
    }

    private void hideHedgehogToEdge() {
        if (hedgehogHiddenAtEdge || hedgehogView == null) return;
        hiddenRestoreX = hedgehogParams.x;
        hiddenRestoreY = hedgehogParams.y;
        hiddenEdgeRight = isHedgehogCloserToRightEdge();
        updateHideActionIcon();
        int offscreenX = hiddenEdgeRight ? getScreenWidth() + dp(6) : -(dp(HEDGEHOG_TOUCH_BOX_DP) + dp(6));
        int targetY = hedgehogParams.y;
        animateHedgehogTravelTo(offscreenX, targetY, true, () -> {
            hedgehogHiddenAtEdge = true;
            if (bubbleVisible) toggleBubble(false);
            if (quickActionsVisible) showQuickActions(false);
            if (hedgehogView != null) hedgehogView.setVisibility(View.GONE);
            positionEdgeTabForHiddenState();
            if (edgeTabView != null) {
                edgeTabView.setVisibility(View.VISIBLE);
                safeUpdate(edgeTabView, edgeTabParams);
            }
            updatePinnedMicVisibility();
        });
    }

    private void restoreHedgehogFromEdge() {
        if (!hedgehogHiddenAtEdge || hedgehogView == null) return;
        if (edgeTabView != null) edgeTabView.setVisibility(View.GONE);
        int restoreX = hiddenRestoreX >= 0 ? hiddenRestoreX : dp(18);
        int restoreY = hiddenRestoreY >= 0 ? hiddenRestoreY : dp(220);
        int offscreenX = hiddenEdgeRight ? getScreenWidth() + dp(6) : -(dp(HEDGEHOG_TOUCH_BOX_DP) + dp(6));
        hedgehogParams.x = offscreenX;
        hedgehogParams.y = clamp(restoreY, 0, Math.max(0, getScreenHeight() - dp(HEDGEHOG_TOUCH_BOX_DP)));
        hedgehogHiddenAtEdge = false;
        hedgehogView.setVisibility(View.VISIBLE);
        safeUpdate(hedgehogView, hedgehogParams);
        animateHedgehogTravelTo(
            clamp(restoreX, 0, Math.max(0, getScreenWidth() - dp(HEDGEHOG_TOUCH_BOX_DP))),
            clamp(restoreY, 0, Math.max(0, getScreenHeight() - dp(HEDGEHOG_TOUCH_BOX_DP))),
            true,
            this::updatePinnedMicVisibility
        );
    }

    private static String safeMessage(Exception e) {
        String m = e.getMessage();
        if (m == null || m.trim().isEmpty()) return e.getClass().getSimpleName();
        return m;
    }
}
